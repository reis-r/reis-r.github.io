<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>FÃ´rÃ§a Bruta! - linux</title><link href="https://reis-r.github.io/" rel="alternate"></link><link href="https://reis-r.github.io/feeds/linux.atom.xml" rel="self"></link><id>https://reis-r.github.io/</id><updated>2020-04-19T00:00:00-03:00</updated><entry><title>Nix: getting Hy in Python 3 for science</title><link href="https://reis-r.github.io/nix-getting-hy-in-python-3-for-science.html" rel="alternate"></link><published>2020-04-19T00:00:00-03:00</published><updated>2020-04-19T00:00:00-03:00</updated><author><name>Rony Reis</name></author><id>tag:reis-r.github.io,2020-04-19:/nix-getting-hy-in-python-3-for-science.html</id><summary type="html">&lt;p&gt;Installing the Hy language from pypi on the Nix package manager&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://reis-r.github.io/basic-nix-configuration.html"&gt;Last post&lt;/a&gt; I showed how I managed to configure my Nix packages. I mentioned it basically replaces the &lt;a href="https://www.anaconda.com/distribution/"&gt;Anaconda distribution&lt;/a&gt;. Today I wanted to start a new school assignment and wanted to do it Hy ðŸ¤¡. I wanted to have a coherent and predictable system that I can count on and that I will not need to bother with dependencies. An example of why this matters is that having installed pandas using Python's &lt;em&gt;venv&lt;/em&gt;, it complained about some missing dependency (&lt;code&gt;libstdc++&lt;/code&gt;, I think, if you're curious) - at the runtime.&lt;/p&gt;
&lt;p&gt;Nix has a Hy package by default, and I can live being on version 0.17.0 (one version behind current), but running on Python 2 (the default on Nix) is unacceptable.&lt;/p&gt;
&lt;h1&gt;Newbie disclaimer about the Nix language&lt;/h1&gt;
&lt;p&gt;Nix is amazing. But most of the time I do something using it I know about half of what is going on. There are some docs and useful resources, but it's often hard to link the points and make sense in order to do what you want to. It's very common to have found the snippets of code you wanted to find, just to realize you don't know where to put it, or how to call it, which command will do what (&lt;code&gt;nix-build&lt;/code&gt;, &lt;code&gt;nix-shell&lt;/code&gt;, &lt;code&gt;nixos-rebuild&lt;/code&gt;...). If that ever happens to you, my advice is to just keep calm and keep messing around, you'll eventually get it. Nix will be mostly fool-proof and will not do anything stupid if it doesn't understand what you want to do. It just fails safe.&lt;/p&gt;
&lt;h1&gt;How to get it done&lt;/h1&gt;
&lt;p&gt;I think it's best to just show the code first and answer questions later:&lt;/p&gt;
&lt;p&gt;EDIT: put the code on pastebin so it won't brake this page on portable devices:
&lt;a href="https://pastebin.com/PnnEYn6c"&gt;&lt;strong&gt;open the code here&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;First of all, what you're doing here is just the same we did on my last blog, you're defining "packages" for your "environment" (I think "derivation" is the correct term). You're supposed to put it side by side (on the same level) of our &lt;code&gt;myPackages&lt;/code&gt; code, the one inside the &lt;code&gt;packageOverrides&lt;/code&gt; block. I tried to outsource it to another file like I did with my Emacs build but I'm yet to figure out how to do it, so my &lt;code&gt;config.nix&lt;/code&gt; is looong.&lt;/p&gt;
&lt;p&gt;Order is not really mandatory on the Nix language since it's lazy. but the first part is the &lt;code&gt;my-hy&lt;/code&gt; thing (should I say "package?"). It builds the Hy language version 0.17.0 &lt;em&gt;automagically&lt;/em&gt; downloading it from pypi and checking the hashes. It also defines some runtime dependencies. You can also set it build dependencies (more on that &lt;a href="https://nixos.org/nixpkgs/manual/#python"&gt;here&lt;/a&gt;). I basically ripped that part from &lt;a href="https://github.com/NixOS/nixpkgs/blob/32749eee42b20eb90718a7639164542159a9e356/pkgs/development/interpreters/hy/default.nix"&gt;the official nixpkgs github repository&lt;/a&gt; and threw away some of the metadata responsible for errors. I tried this with the newest Hy version, 0.18.0, but it promptly complained about dependencies not being up to date. As 0.17.0 is good enough (if the Python version isn't legacy), I didn't go further.&lt;/p&gt;
&lt;p&gt;The second part (&lt;code&gt;my-python-packages&lt;/code&gt; on the code) is just for defining which python packages I wanted installed together with Hy. Without it you would get the Hy package but it wouldn't find python libraries installed (at least here it didn't) in the system, which is the hole point of using Hy. I'm pretty sure this is how Nix is supposed to work anyway, to avoid conflicts between packages, which is actually pretty cool. The third package-but-not-really is &lt;code&gt;python-env&lt;/code&gt;, it is, as explained &lt;a href="https://nixos.wiki/wiki/Python"&gt;here&lt;/a&gt; just applying the function &lt;code&gt;my-python-packages&lt;/code&gt; (oh yeah, function!) and saying "hey, install Python and the packages on &lt;code&gt;my-python-packages&lt;/code&gt;, thank you".&lt;/p&gt;
&lt;p&gt;After coding this to your configuration file, all you need to do is to &lt;code&gt;python-env&lt;/code&gt; on your packages list like just another package you want to install. And off you go.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;I'll try to adapt this into a proper system package and send a PR to the Nixpkgs guys so everyone can use this great language on this really nice system, but I can't promise anything. Also, I bet I did some things wrong here. The classic disclaimer is in order: don't try this at home, I'm not responsible if you accidentally set yourself on fire.&lt;/p&gt;
&lt;p&gt;Outside from Hy, I don't think I really need anything out of ordinary in Python. You really should do all of this configuration in a per-project basis but I'm one lazy bastard. If I ever need some feature in 0.18.0 (it's a very nice release) I'll do it. I'll try to write about my Emacs configuration on Nix in the future, it's quite nice and actually easier than this. &lt;/p&gt;</content><category term="linux"></category><category term="hy"></category><category term="python"></category><category term="nix"></category></entry><entry><title>Basic Nix configuration</title><link href="https://reis-r.github.io/basic-nix-configuration.html" rel="alternate"></link><published>2020-04-18T00:00:00-03:00</published><updated>2020-04-18T00:00:00-03:00</updated><author><name>Rony Reis</name></author><id>tag:reis-r.github.io,2020-04-18:/basic-nix-configuration.html</id><summary type="html">&lt;p&gt;A basic Nix package manager configuration for home use&lt;/p&gt;</summary><content type="html">&lt;p&gt;I'm a distro hopper and I frequently try new and weird systems, but now I think I managed to find balance on NixOS. NixOS is a Linux distribution that uses a really nice package manager called Nix. The system and package manager are configured using a functional language. In this post I'll describe how I configured my system.&lt;/p&gt;
&lt;h1&gt;How it works&lt;/h1&gt;
&lt;p&gt;You can install the Nix package manager in any Linux distro (and Mac), it has some nice features. The general idea is that you describe what you want your system to be on a script and then it does as you wish, and just that. On NixOS most of your system configuration goes on the file &lt;code&gt;/etc/nixos/configuation.nix&lt;/code&gt;. You can, leave it for the users of your system to choose which packages to install (the packages manager does that by default). You can even use &lt;code&gt;.nix&lt;/code&gt; files to manage development environments and temporally install compilers just for building or running some piece of code. I'm using it instead of Anaconda and it does the same job very well (and with more packages and options).&lt;/p&gt;
&lt;h1&gt;How to go about it&lt;/h1&gt;
&lt;p&gt;I put on my &lt;code&gt;configuration.nix&lt;/code&gt; just system-wide stuff, like services, system configuration, X11, window manager, desktop manager, etc. There's is a lot of documentation for it on the web. You can also install programs using the command line as normal user like any other package manager. But what I find interesting is to pick the software collection using a text file so I can have a notion of what I have installed. You can also backup this file and re-install everything with one single command, if you ever need to. &lt;/p&gt;
&lt;p&gt;The actual programs I install as normal user by the means of the &lt;code&gt;~/.config/nixpkgs/config.nix&lt;/code&gt;. Basically what you need to do there is to define a new "package" with all the software you want installed. My configuration looks like that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;packageOverrides&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;pkgs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pkgs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;myPackages&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buildEnv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;my-cool-programs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;paths&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;&lt;/span&gt;
&lt;span class="n"&gt;            # internet&lt;/span&gt;
&lt;span class="n"&gt;            firefox&lt;/span&gt;
&lt;span class="n"&gt;            &amp;lt;packages go here...&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;            &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So in that case, "my-cool-programs" is our "package" (I'm pretty sure this is not the right jargon for this). What you need to do then is to run &lt;code&gt;nix-env -i my-cool-programs --remove-all&lt;/code&gt;. This will install the packages you mentioned on the configuation. The &lt;code&gt;--remove-all&lt;/code&gt; option means that you will remove everything you had before installing your package, I think the system-wide command for building the system (&lt;code&gt;nixos-rebuild&lt;/code&gt;) may work in similar way behind the scenes.&lt;/p&gt;
&lt;p&gt;Bonus points: I created Emacs commands for both editing the configuration file and running the install command. &lt;em&gt;stonks&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;There is more. Lot more. But I'm pretty happy with this simple setup already. You can also use &lt;code&gt;.nix&lt;/code&gt; files to create temporary environments you can do if for building/testing software or for running environments like conda/virtualenv (good for Jupyter notebooks).&lt;/p&gt;</content><category term="linux"></category><category term="unix"></category><category term="nix"></category><category term="nixos"></category><category term="operating systems"></category></entry></feed>